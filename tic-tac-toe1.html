<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe (White Style)</title>

    <!-- gemini -->

    <style>
        /* * 깔끔한 화이트 스타일 CSS (No Framework)
         */
        :root {
            --cell-size: 100px;
            --mark-size: calc(var(--cell-size) * 0.9);
            --bg-color: #ffffff;
            --line-color: #333333;
            --hover-color: #e0e0e0;
            --text-color: #333;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        /* 보드 레이아웃 */
        .board {
            display: grid;
            grid-template-columns: repeat(3, auto);
            justify-content: center;
            align-content: center;
        }

        /* 셀 스타일 */
        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 2px solid var(--line-color);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
        }

        /* 외곽 테두리 제거 (깔끔한 # 모양 만들기) */
        .cell:first-child, .cell:nth-child(2), .cell:nth-child(3) { border-top: none; }
        .cell:nth-child(3n + 1) { border-left: none; }
        .cell:nth-child(3n) { border-right: none; }
        .cell:last-child, .cell:nth-child(8), .cell:nth-child(7) { border-bottom: none; }

        /* 이미 클릭된 셀 커서 변경 */
        .cell.x, .cell.circle {
            cursor: not-allowed;
        }

        /* --- X 마크 그리기 (CSS) --- */
        .cell.x::before,
        .cell.x::after,
        .board.x .cell:not(.x):not(.circle):hover::before,
        .board.x .cell:not(.x):not(.circle):hover::after {
            content: '';
            position: absolute;
            width: calc(var(--mark-size) * 0.15);
            height: var(--mark-size);
            background-color: var(--line-color);
        }

        .cell.x::before,
        .board.x .cell:not(.x):not(.circle):hover::before {
            transform: rotate(45deg);
        }

        .cell.x::after,
        .board.x .cell:not(.x):not(.circle):hover::after {
            transform: rotate(-45deg);
        }

        /* --- O 마크 그리기 (CSS) --- */
        .cell.circle::before,
        .cell.circle::after,
        .board.circle .cell:not(.x):not(.circle):hover::before,
        .board.circle .cell:not(.x):not(.circle):hover::after {
            content: '';
            position: absolute;
            border-radius: 50%;
        }

        .cell.circle::before,
        .board.circle .cell:not(.x):not(.circle):hover::before {
            width: var(--mark-size);
            height: var(--mark-size);
            background-color: var(--line-color);
        }

        .cell.circle::after,
        .board.circle .cell:not(.x):not(.circle):hover::after {
            width: calc(var(--mark-size) * 0.7);
            height: calc(var(--mark-size) * 0.7);
            background-color: var(--bg-color); /* 배경색으로 덮어서 도넛 모양 만듦 */
        }

        /* --- 호버 효과 (회색으로 미리보기) --- */
        .board.x .cell:not(.x):not(.circle):hover::before,
        .board.x .cell:not(.x):not(.circle):hover::after,
        .board.circle .cell:not(.x):not(.circle):hover::before {
            background-color: var(--hover-color);
        }

        /* --- 승리 메시지 모달 --- */
        .winning-message {
            display: none; /* 기본 숨김 */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.95);
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-size: 3rem;
            color: var(--text-color);
            z-index: 10;
        }

        .winning-message button {
            font-size: 1.5rem;
            background-color: var(--text-color);
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            transition: opacity 0.3s ease;
        }

        .winning-message button:hover {
            opacity: 0.8;
        }

        .winning-message.show {
            display: flex;
        }
    </style>
</head>
<body>

<div class="board" id="board">
    <div class="cell" data-cell></div>
    <div class="cell" data-cell></div>
    <div class="cell" data-cell></div>
    <div class="cell" data-cell></div>
    <div class="cell" data-cell></div>
    <div class="cell" data-cell></div>
    <div class="cell" data-cell></div>
    <div class="cell" data-cell></div>
    <div class="cell" data-cell></div>
</div>

<div class="winning-message" id="winningMessage">
    <div data-winning-message-text></div>
    <button id="restartButton">다시하기</button>
</div>

<script>
    const X_CLASS = "x"
    const CIRCLE_CLASS = "circle"
    const WINNING_COMBINATIONS = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
        [0, 3, 6],
        [1, 4, 7],
        [2, 5, 8],
        [0, 4, 8],
        [2, 4, 6]
    ]

    const cellElements = document.querySelectorAll("[data-cell]")
    const board = document.getElementById("board")
    const winningMessageElement = document.getElementById("winningMessage")
    const restartButton = document.getElementById("restartButton")
    const winningMessageTextElement = document.querySelector("[data-winning-message-text]")
    let circleTurn

    startGame()

    restartButton.addEventListener("click", startGame)

    function startGame() {
        circleTurn = false
        cellElements.forEach(cell => {
            cell.classList.remove(X_CLASS)
            cell.classList.remove(CIRCLE_CLASS)
            cell.removeEventListener("click", handleClick)
            cell.addEventListener("click", handleClick, { once: true })
        })
        setBoardHoverClass()
        winningMessageElement.classList.remove("show")
    }

    function handleClick(e) {
        const cell = e.target
        const currentClass = circleTurn ? CIRCLE_CLASS : X_CLASS
        placeMark(cell, currentClass)
        if (checkWin(currentClass)) {
            endGame(false)
        } else if (isDraw()) {
            endGame(true)
        } else {
            swapTurns()
            setBoardHoverClass()
        }
    }

    function endGame(draw) {
        if (draw) {
            winningMessageTextElement.innerText = "비겼어!"
        } else {
            // 수정: 템플릿 리터럴 문법 오류(백틱 `) 수정
            winningMessageTextElement.innerText = `${circleTurn ? "O가" : "X가"} 이겼어!`
        }
        winningMessageElement.classList.add("show")
    }

    function isDraw() {
        return [...cellElements].every(cell => {
            return cell.classList.contains(X_CLASS) || cell.classList.contains(CIRCLE_CLASS)
        })
    }

    function placeMark(cell, currentClass) {
        cell.classList.add(currentClass)
    }

    function swapTurns() {
        circleTurn = !circleTurn
    }

    function setBoardHoverClass() {
        board.classList.remove(X_CLASS)
        board.classList.remove(CIRCLE_CLASS)
        if (circleTurn) {
            board.classList.add(CIRCLE_CLASS)
        } else {
            board.classList.add(X_CLASS)
        }
    }

    function checkWin(currentClass) {
        return WINNING_COMBINATIONS.some(combination => {
            return combination.every(index => {
                return cellElements[index].classList.contains(currentClass)
            })
        })
    }
</script>
</body>
</html>