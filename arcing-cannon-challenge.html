<!-- file: arcing-cannon-challenge.html -->

<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ì•„í¬ ìºë…¼ ì±Œë¦°ì§€</title>

    <!-- https://www.jiraksil.com/service/arcing-cannon -->

    <style>
        :root{
            --bg:#ffffff;
            --card:#ffffff;
            --text:#111827;
            --muted:#6b7280;
            --border:#e5e7eb;
            --shadow: 0 12px 30px rgba(0,0,0,.08);

            --primary:#2563eb;
            --primary2:#06b6d4;
            --danger:#ef4444;
            --ok:#22c55e;
        }

        *{ box-sizing:border-box; }
        html,body{ height:100%; }
        body{
            margin:0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
        }

        .page{
            max-width: 920px;
            margin: 0 auto;
            padding: 18px 14px 70px;
        }

        /* Header */
        .topbar{
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap:12px;
            margin-bottom: 14px;
        }
        .brand{
            display:flex;
            align-items:center;
            gap:10px;
            font-weight:900;
            letter-spacing:-.3px;
            font-size: 16px;
        }
        .brand-badge{
            width:34px;height:34px;
            border-radius:10px;
            display:grid;
            place-items:center;
            color:#fff;
            background: linear-gradient(135deg, var(--primary), var(--primary2));
            box-shadow: 0 10px 20px rgba(37,99,235,.18);
        }

        .card{
            background: var(--card);
            border:1px solid var(--border);
            border-radius: 18px;
            box-shadow: var(--shadow);
            overflow:hidden;
        }
        .card-pad{ padding: 16px; }

        .title{
            margin:0 0 8px;
            font-size: 18px;
            font-weight: 900;
            letter-spacing:-.3px;
        }
        .desc{
            margin:0;
            color: var(--muted);
            line-height:1.65;
            font-size: 14px;
        }

        /* Game Area */
        .game-wrap{
            margin-top: 14px;
        }

        #game-display{
            width:100%;
            height: 380px;
            display:flex;
            justify-content:center;
            align-items:center;
            background:#fff;
            position:relative;
            border-radius: 18px;
            border: 1px solid var(--border);
            overflow:hidden;
        }

        canvas{
            display:block;
            background-color:#87CEEB; /* sky */
            border-radius: 14px;
            border: 1px solid rgba(0,0,0,.06);
            box-shadow: 0 12px 24px rgba(0,0,0,.10);
            touch-action: none; /* ëª¨ë°”ì¼ ë“œë˜ê·¸ ìŠ¤í¬ë¡¤ ë°©ì§€ */
        }

        /* UI bar */
        #ui{
            position:absolute;
            top: 10px;
            left: 10px;
            display:none;
            padding: 8px 10px;
            border-radius: 999px;
            background: rgba(17,24,39,.72);
            color:#fff;
            font-weight: 900;
            font-size: 13px;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,.18);
        }

        /* Start/End overlay */
        .overlay{
            position:absolute;
            width: 260px;
            max-width: calc(100% - 26px);
            background: rgba(17,24,39,.86);
            color:#fff;
            display:flex;
            justify-content:center;
            align-items:center;
            text-align:center;
            border-radius: 16px;
            padding: 14px;
            border: 1px solid rgba(255,255,255,.18);
            box-shadow: 0 18px 30px rgba(0,0,0,.20);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        #start-screen{ display:flex; }
        #end-screen{ display:none; }

        .overlay .small{
            color: rgba(255,255,255,.75);
            font-weight: 700;
            font-size: 12px;
            line-height: 1.45;
            margin-top: 8px;
        }

        .btn{
            width: 100%;
            margin-top: 12px;
            border: 0;
            cursor:pointer;
            border-radius: 14px;
            padding: 12px 14px;
            font-weight: 900;
            font-size: 14px;
            color:#0b1020;
            background: linear-gradient(135deg, rgba(37,99,235,.85), rgba(6,182,212,.75));
            box-shadow: 0 12px 20px rgba(37,99,235,.20);
            transition: transform .12s ease, box-shadow .12s ease;
        }
        .btn:hover{ transform: translateY(-1px); box-shadow: 0 16px 26px rgba(37,99,235,.24); }
        .btn:active{ transform: scale(.98); }

        .info-card{
            margin-top: 14px;
            padding: 14px;
            background:#fff;
            border:1px solid var(--border);
            border-radius: 18px;
            box-shadow: var(--shadow);
        }

        .hint{
            margin-top: 10px;
            font-size: 12px;
            color: var(--muted);
        }

        @media (max-width: 480px){
            #game-display{ height: 360px; }
        }
    </style>
</head>

<body>
<div class="page">
    <div class="topbar">
        <div class="brand">
            <div class="brand-badge">ğŸ¯</div>
            <div>ì•„í¬ ìºë…¼ ì±Œë¦°ì§€</div>
        </div>
    </div>

    <div class="card">
        <div class="card-pad">
            <h1 class="title">íƒ„ë„ë¥¼ ì¡°ì ˆí•´ì„œ ëª©í‘œë¬¼ì„ ë§ì¶°ë³´ì„¸ìš”</h1>
            <p class="desc">
                í•œ ë ˆë²¨ì— 60ì´ˆê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. ëª©í‘œë¬¼ì— ëª…ì¤‘í•˜ë©´ ë‹¤ìŒ ë ˆë²¨ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.<br />
                ì‹œì‘ í›„ ì»¤ì„œ(ë˜ëŠ” í„°ì¹˜)ë¡œ ê°ë„ë¥¼ ì¡°ì ˆí•˜ê³ , <b>ëˆ„ë¥´ê³  ìˆìœ¼ë©´ íŒŒì›Œê°€ ì°¨ê³ </b> ë–¼ë©´ ë°œì‚¬ë©ë‹ˆë‹¤.
            </p>

            <div class="game-wrap">
                <div id="game-display">
                    <div id="ui">ë ˆë²¨: <span id="level">1</span> | ì‹œê°„: <span id="time">60</span></div>

                    <div id="start-screen" class="overlay">
                        <div>
                            <div style="font-weight:900;font-size:14px;">íƒ„ë„ë¥¼ ì¡°ì ˆí•´ì„œ ëª©í‘œë¬¼ì„ ë§ì¶°ë³´ì„¸ìš”</div>
                            <div class="small">ëª¨ë°”ì¼ì€ ê°€ë¡œëª¨ë“œê°€ ë” í¸í•©ë‹ˆë‹¤.</div>
                            <button class="btn" id="start-button" type="button">í…ŒìŠ¤íŠ¸ ì‹œì‘</button>
                        </div>
                    </div>

                    <div id="end-screen" class="overlay">
                        <div>
                            <div id="end-message" style="font-weight:900;font-size:14px;"></div>
                            <button class="btn" id="restart-button" type="button">ë‹¤ì‹œí•˜ê¸°</button>
                        </div>
                    </div>

                    <canvas id="gameCanvas" aria-label="ì•„í¬ ìºë…¼ ìº”ë²„ìŠ¤"></canvas>
                </div>
            </div>

            <div class="hint">
                * íŒ: ë„ˆë¬´ ì„¸ê²Œ ì˜ë©´ ë„˜ì–´ê°€ê³ , ë„ˆë¬´ ì•½í•˜ë©´ ëª» ê°‘ë‹ˆë‹¤. ê°ë„ì™€ íŒŒì›Œì˜ ê· í˜•ì´ í•µì‹¬!
            </div>
        </div>
    </div>

    <div class="info-card">
        ì•„í¬ ìºë…¼ í…ŒìŠ¤íŠ¸ëŠ” ê³µê°„ì§€ê°ë ¥, ê°ë„ ê³„ì‚° ëŠ¥ë ¥, í˜ ì¡°ì ˆ ëŠ¥ë ¥, ì „ëµì  ì‚¬ê³  ëŠ¥ë ¥ì„ ìš”êµ¬í•©ë‹ˆë‹¤.
        ëª©í‘œë¬¼ ìœ„ì¹˜/ì¥ì• ë¬¼ ë°°ì¹˜ë¥¼ ë³´ê³  â€œê°ë„ + íŒŒì›Œâ€ë¥¼ ì¡°í•©í•´ ëª…ì¤‘ì‹œí‚¤ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.
    </div>
</div>

<script>
    /*********************************************************
     * Vanilla JS - Arcing Cannon Challenge (No rank / No ads)
     *********************************************************/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const uiEl = document.getElementById('ui');
    const levelEl = document.getElementById('level');
    const timeEl = document.getElementById('time');
    const startScreen = document.getElementById('start-screen');
    const endScreen = document.getElementById('end-screen');
    const endMessage = document.getElementById('end-message');

    const startBtn = document.getElementById('start-button');
    const restartBtn = document.getElementById('restart-button');

    // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •(ì»¨í…Œì´ë„ˆ ê¸°ì¤€)
    function resizeCanvas(){
        const wrap = document.getElementById('game-display');
        const rect = wrap.getBoundingClientRect();

        // ì›ë³¸ ë¡œì§ ê°ì•ˆ: ë„ˆë¬´ ì‘ìœ¼ë©´ ìµœì†Œí­ í™•ë³´
        let w = Math.max(460, Math.floor(rect.width - 24));
        let h = Math.floor(rect.height - 24);

        // ëª¨ë°”ì¼ì—ì„œ ë„ˆë¬´ ë†’ì§€ ì•Šê²Œ
        h = Math.max(320, Math.min(420, h));

        canvas.width = w;
        canvas.height = h;
    }

    resizeCanvas();
    window.addEventListener('resize', () => {
        const running = isRunning;
        resizeCanvas();
        if (running) {
            // ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ë¬¼ë¦¬/ì¢Œí‘œê°€ ë°”ë€Œë¯€ë¡œ ë ˆë²¨ ë¦¬ì…‹ ëŒ€ì‹  í˜„ì¬ ë ˆë²¨ ê·¸ëŒ€ë¡œ ì¬ë°°ì¹˜
            resetLevel(false);
        } else {
            // ì‹œì‘ ì „/ì¢…ë£Œ í™”ë©´ì—ì„œë„ ìº”ë²„ìŠ¤ëŠ” ë‹¤ì‹œ ê·¸ë ¤ì¤Œ
            renderFrame();
        }
    });

    // ê²Œì„ ìƒìˆ˜/ìƒíƒœ
    let isRunning = false;

    const gravity = 0.5;

    function groundY(){ return canvas.height * 0.8; }

    const cannon = { x: 100, y: 0, width: 40, height: 40, angle: 45 };

    let target = { x: 0, y: 0, radius: 25 };

    const projectile = {
        x: 0, y: 0, radius: 6,
        speed: 0, angle: 0,
        active: false,
        vx: 0, vy: 0
    };

    let obstacles = [];

    let level = 1;
    let timeLeft = 60;
    let gameInterval = null;
    let timeInterval = null;

    let charging = false;
    let chargeLevel = 0;
    let chargeInterval = null;

    // ì´í™íŠ¸
    let targetHit = false;
    let targetOpacity = 1.0;
    let lastShotPower = 0;

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function rand(min, max){ return Math.random() * (max - min) + min; }

    function resetLevel(resetTimer = true){
        cannon.y = groundY() - 10;

        randomizeTargetPosition();
        generateObstacles();

        projectile.active = false;
        targetHit = false;
        targetOpacity = 1.0;

        if (resetTimer){
            timeLeft = 60;
            timeEl.textContent = timeLeft;
        }
    }

    function randomizeTargetPosition(){
        const gy = groundY();
        const minX = (level <= 5) ? 200 : (canvas.width / 2);
        const maxX = canvas.width - 100;

        target.x = rand(minX, maxX);
        target.y = gy;

        target.radius = rand(15, 25);
    }

    function generateObstacles(){
        const num = Math.floor(Math.random() * 5) + 1;
        obstacles = [];

        const safe = 110;
        for (let i=0;i<num;i++){
            let w = rand(50, 100);
            let h = rand(30, 100);
            let x = rand(0, canvas.width - w);

            while ((x > cannon.x - safe && x < cannon.x + safe) ||
            (x > target.x - safe && x < target.x + safe)) {
                x = rand(0, canvas.width - w);
            }
            obstacles.push({ x, width: w, height: h });
        }
    }

    // Draw
    function drawGround(){
        const gy = groundY();
        ctx.fillStyle = '#654321';
        ctx.fillRect(0, gy, canvas.width, canvas.height - gy);
        drawObstacles();
    }

    function drawObstacles(){
        const gy = groundY();
        ctx.fillStyle = '#8B4513';
        obstacles.forEach(o=>{
            ctx.beginPath();
            const half = o.width/2;
            ctx.moveTo(o.x, gy);
            ctx.lineTo(o.x + half, gy - o.height);
            ctx.lineTo(o.x + o.width, gy);
            ctx.closePath();
            ctx.fill();
        });
    }

    function drawCannon(){
        ctx.save();
        ctx.translate(cannon.x, cannon.y);
        ctx.rotate(-cannon.angle * Math.PI / 180);

        ctx.fillStyle = '#000';
        ctx.fillRect(-cannon.width/2, -cannon.height/2, cannon.width, cannon.height);

        ctx.fillStyle = '#555';
        ctx.fillRect(0, -5, cannon.width, 10);

        ctx.restore();

        drawChargeBar();
    }

    function drawChargeBar(){
        // base bar
        const barW = 130;
        const barH = 7;
        const x = cannon.x - barW/2;
        const y = cannon.y - cannon.height - 14;

        ctx.fillStyle = 'rgba(255,255,255,.85)';
        ctx.fillRect(x, y, barW, barH);

        // fill
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(x, y, barW * (chargeLevel / 100), barH);

        // ticks
        ctx.fillStyle = 'rgba(0,0,0,.7)';
        for(let i=0;i<=10;i++){
            const tx = x + (i * (barW/10));
            ctx.fillRect(tx, y - 5, 1, 5);
        }

        // number
        ctx.fillStyle = '#111';
        ctx.font = 'bold 18px Arial';
        ctx.fillText(String(chargeLevel), cannon.x - 10, y - 10);
    }

    function drawTarget(){
        if (targetHit){
            ctx.fillStyle = `rgba(255,0,0,${targetOpacity})`;
            ctx.beginPath();
            ctx.arc(target.x, target.y, target.radius, 0, Math.PI*2);
            ctx.fill();

            if (targetOpacity > 0){
                target.y -= 1;
                targetOpacity -= 0.02;
            }
        } else {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(target.x, target.y, target.radius, 0, Math.PI*2);
            ctx.fill();
        }
    }

    function drawProjectile(){
        if (!projectile.active) return;
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI*2);
        ctx.fill();
    }

    function drawPowerDisplay(){
        // ì›ë³¸ì€ í•­ìƒ í‘œì‹œ ì¤‘ì´ì–´ì„œ ê·¸ëŒ€ë¡œ ìœ ì§€
        const boxW = 150, boxH = 92;
        const boxX = cannon.x - boxW/2;
        const boxY = cannon.y - cannon.height - 160;

        ctx.fillStyle = 'rgba(255,255,255,0.75)';
        ctx.fillRect(boxX, boxY, boxW, boxH);

        ctx.fillStyle = '#111';
        ctx.font = '14px Arial';
        ctx.fillText(`ê°ë„: ${Math.round(cannon.angle)}Â°`, boxX + 10, boxY + 28);
        ctx.fillText(`íŒŒì›Œ: ${lastShotPower}`, boxX + 10, boxY + 50);
        ctx.fillText(`ì†ë„: ${Math.round(projectile.speed)}`, boxX + 10, boxY + 72);
    }

    function updateProjectile(){
        if (!projectile.active) return;

        const gy = groundY();

        projectile.vy += gravity;
        projectile.x += projectile.vx;
        projectile.y += projectile.vy;

        // target collision
        const dx = projectile.x - target.x;
        const dy = projectile.y - target.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < projectile.radius + target.radius){
            projectile.active = false;
            hitTargetEffect();
            return;
        }

        // ground
        if (projectile.y + projectile.radius >= gy){
            projectile.active = false;
            return;
        }

        // obstacles collision (triangle bounds is complex)
        // ì›ë³¸ì²˜ëŸ¼ ëŒ€ëµì ì¸ ì‚¬ê° íŒì • + ë°”ë‹¥ ê·¼ì²˜ íŒì • ìœ ì§€
        for (const o of obstacles){
            if (projectile.x > o.x && projectile.x < o.x + o.width &&
                projectile.y > gy - o.height && projectile.y < gy){
                projectile.active = false;
                return;
            }
            if (projectile.x + projectile.radius >= o.x &&
                projectile.x - projectile.radius <= o.x + o.width &&
                projectile.y + projectile.radius >= gy - o.height) {
                projectile.active = false;
                return;
            }
        }

        // out of bounds
        if (projectile.x < -50 || projectile.x > canvas.width + 50 || projectile.y < -100){
            projectile.active = false;
        }
    }

    function hitTargetEffect(){
        targetHit = true;
        targetOpacity = 1.0;

        const interval = setInterval(()=>{
            if (targetOpacity <= 0){
                clearInterval(interval);
                nextLevel();
            }
        }, 30);
    }

    function nextLevel(){
        level++;
        levelEl.textContent = level;
        resetLevel(true);
    }

    function updateTime(){
        if (timeLeft > 0){
            timeLeft--;
            timeEl.textContent = timeLeft;
        } else {
            endGame();
        }
    }

    function endGame(){
        stopLoops();
        isRunning = false;

        endMessage.innerHTML = `í…ŒìŠ¤íŠ¸ ì¢…ë£Œ!<br>ìµœì¢… ë ˆë²¨ ${level}`;
        endScreen.style.display = 'flex';
        uiEl.style.display = 'none';
    }

    function stopLoops(){
        if (gameInterval) { clearInterval(gameInterval); gameInterval = null; }
        if (timeInterval) { clearInterval(timeInterval); timeInterval = null; }
        if (chargeInterval) { clearInterval(chargeInterval); chargeInterval = null; }
        charging = false;
        chargeLevel = 0;
    }

    function startGame(){
        stopLoops();
        isRunning = true;

        level = 1;
        timeLeft = 60;
        levelEl.textContent = level;
        timeEl.textContent = timeLeft;

        startScreen.style.display = 'none';
        endScreen.style.display = 'none';
        uiEl.style.display = 'block';

        resetLevel(true);

        gameInterval = setInterval(gameLoop, 1000/50);
        timeInterval = setInterval(updateTime, 1000);
    }

    // Input helpers
    function getPointerPos(evt){
        const rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    function updateCannonAngleByPoint(px, py){
        const dx = px - cannon.x;
        const dy = cannon.y - py;
        cannon.angle = Math.atan2(dy, dx) * 180 / Math.PI;
        // ë’¤ë¡œ ì˜ëŠ” ê°ë„ ë°©ì§€(ì„ íƒ): -10~170 ì •ë„ ì œí•œ
        cannon.angle = clamp(cannon.angle, 0, 90);
    }

    function startCharging(){
        if (!isRunning) return;
        charging = true;
        chargeLevel = 0;

        if (chargeInterval) clearInterval(chargeInterval);
        chargeInterval = setInterval(()=>{
            if (!charging) return;
            chargeLevel += 2;
            if (chargeLevel > 100) chargeLevel = 0;
        }, 30);
    }

    function releaseCharge(){
        if (!isRunning) return;
        if (!charging) return;

        charging = false;
        if (chargeInterval) { clearInterval(chargeInterval); chargeInterval = null; }

        if (!projectile.active){
            projectile.x = cannon.x;
            projectile.y = cannon.y;
            projectile.angle = cannon.angle;
            projectile.speed = chargeLevel / 3;

            projectile.vx = Math.cos(projectile.angle * Math.PI/180) * projectile.speed;
            projectile.vy = -Math.sin(projectile.angle * Math.PI/180) * projectile.speed;
            projectile.active = true;

            lastShotPower = chargeLevel;
            chargeLevel = 0;
        }
    }

    // Mouse events
    canvas.addEventListener('mousemove', (e)=>{
        if (!isRunning) return;
        const p = getPointerPos(e);
        updateCannonAngleByPoint(p.x, p.y);
    });
    canvas.addEventListener('mousedown', (e)=>{
        if (!isRunning) return;
        startCharging();
    });
    window.addEventListener('mouseup', (e)=>{
        // ìº”ë²„ìŠ¤ ë°–ì—ì„œ ë–¼ì–´ë„ ë°œì‚¬ë˜ê²Œ
        if (!isRunning) return;
        releaseCharge();
    });

    // Touch events
    canvas.addEventListener('touchstart', (e)=>{
        if (!isRunning) return;
        e.preventDefault();
        const t = e.touches[0];
        const p = getPointerPos(t);
        updateCannonAngleByPoint(p.x, p.y);
        startCharging();
    }, {passive:false});

    canvas.addEventListener('touchmove', (e)=>{
        if (!isRunning) return;
        e.preventDefault();
        const t = e.touches[0];
        const p = getPointerPos(t);
        updateCannonAngleByPoint(p.x, p.y);
    }, {passive:false});

    canvas.addEventListener('touchend', (e)=>{
        if (!isRunning) return;
        e.preventDefault();
        releaseCharge();
    }, {passive:false});

    // Main loop
    function renderFrame(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        drawGround();
        drawCannon();
        drawTarget();
        drawProjectile();
        drawPowerDisplay();
    }

    function gameLoop(){
        renderFrame();
        updateProjectile();
    }

    // initial render
    resetLevel(true);
    renderFrame();

    // buttons
    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);
</script>
</body>
</html>